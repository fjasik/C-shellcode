import argparse

delete_starting_with = "INCLUDELIB"
append_after_line = "PUBLIC\tmain"
delete_from = "pdata\tSEGMENT"
delete_until = "_TEXT\tSEGMENT"
register_string = "PTR gs:"

align_stack_procedure = """
; https://github.com/mattifestation/PIC_Bindshell/blob/master/PIC_Bindshell/AdjustStack.asm

; AlignRSP is a simple call stub that ensures that the stack is 16-byte aligned prior
; to calling the entry point of the payload. This is necessary because 64-bit functions
; in Windows assume that they were called with 16-byte stack alignment. When amd64
; shellcode is executed, you can't be assured that you stack is 16-byte aligned. For example,
; if your shellcode lands with 8-byte stack alignment, any call to a Win32 function will likely
; crash upon calling any ASM instruction that utilizes XMM registers (which require 16-byte)
; alignment.

preMainAlign PROC
    push rsi                    ; Preserve RSI since we're stomping on it
    mov rsi, rsp                ; Save the value of RSP so it can be restored
    and rsp, 0FFFFFFFFFFFFFFF0h ; Align RSP to 16 bytes
    sub rsp, 020h               ; Allocate homing space for ExecutePayload
    call main                   ; Call the entry point of the payload
    mov rsp, rsi                ; Restore the original value of RSP
    pop rsi                     ; Restore RSI
    ret                         ; Return to caller
preMainAlign ENDP

"""


def process_file(input_file, output_file):
    print(f"Amending assembly file: {input_file}")

    with open(input_file, "r") as infile, open(output_file, "w") as outfile:
        delete_mode = False
        found_delete_until = False

        outfile.write(
            "; This file is a result of manipulation of the assembly listing autogenerated by cl.exe.\n"
        )
        outfile.write(
            "; Microsoft claims that x64 assembly can contain errors and this version\n"
        )
        outfile.write(
            "; attempts to remove those errors to allow further assembly. No guarantees are given.\n\n"
        )

        for line in infile:
            # Skip lines starting with "INCLUDELIB"
            if line.startswith(delete_starting_with):
                print(f"Removed line: {line.strip()}")
                continue

            # Add the declaration of preMainAlign
            if line.strip() == append_after_line:
                declaration = "PUBLIC\tpreMainAlign\n"
                print(f"Appended line: {declaration.strip()}")
                outfile.write(line)
                outfile.write(declaration)
                continue

            # Start deleting from "COMDAT pdata"
            if delete_from in line:
                delete_mode = True
                continue

            # Stop deleting after reaching "_TEXT    SEGMENT" (include that line)
            # Insert the stack allignment stub
            if delete_until in line and not found_delete_until:
                found_delete_until = True
                delete_mode = False

                outfile.write(line)

                print("Deleted PDATA and XDATA sections")

                outfile.write(align_stack_procedure)

                print(
                    "Inserted the stack alignment procedure (link against: preMainAlign)"
                )

                continue

            # Skip lines inside the block to delete
            if delete_mode:
                continue

            # TBD if this is required
            # We fix the fs register instruction
            # Replace PTR fs:40 with PTR fs:[40]
            if (index := line.find(register_string)) != -1:
                offset = line[index + len(register_string) :].rstrip("\n")
                line = line[:index] + f"{register_string}[{offset}]\n"
                print(f"Fixed syntax error in line:  {line.strip()}")

            outfile.write(line)

    print("Done")


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("file_in", help="Path to the autogenerated asm file")
    parser.add_argument("file_out", help="Path to the amended asm file")
    args = parser.parse_args()

    process_file(args.file_in, args.file_out)


if __name__ == "__main__":
    main()
