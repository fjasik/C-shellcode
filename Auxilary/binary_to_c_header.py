import argparse
import os


def binary_to_cpp_header(input_file, output_file, namespace, trim):
    input_file_relative = os.path.relpath(input_file)
    with open(input_file, "rb") as file:
        binary_data = file.read()

    if trim:
        binary_data = binary_data.rstrip(b"\x00")

    with open(output_file, "w") as file:
        file.write("#pragma once\n\n")

        file.write(f"// This file was autogenerated from {input_file_relative}\n\n")

        if namespace:
            file.write(f"namespace {namespace} {{\n")
        else:
            file.write("namespace {\n")

        file.write("\tstatic constexpr unsigned char shellcodeArray[] = {\n")

        chunk_size = 20
        for i in range(0, len(binary_data), chunk_size):
            chunk = binary_data[i : i + chunk_size]

            result_string = ""

            hex_bytes = [f"0x{byte:02X}" for byte in chunk]
            result_string += ", ".join(hex_bytes)

            # This keeps a trailing comma in the array
            file.write(f"\t\t{result_string},\n")

        file.write("\t};\n")
        file.write("}")

    array_size = len(binary_data)
    print(f"Successfully generated array with size {array_size} bytes")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Convert a binary file to a C++ header file with an unsigned char array."
    )
    parser.add_argument("input_file", help="Path to the input binary file")
    parser.add_argument("output_file", help="Path to the output C++ header file")
    parser.add_argument(
        "-n",
        "--namespace",
        help="Namespace to use for the array (default: anonymous namespace)",
        default=None,
    )
    parser.add_argument(
        "-trim", action="store_true", help="Trim trailing zeros from the binary data"
    )

    args = parser.parse_args()

    binary_to_cpp_header(args.input_file, args.output_file, args.namespace, args.trim)
